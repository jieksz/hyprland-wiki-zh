---
title: PR 指导
---

## PR 必要条件

- 干净, 不黑客的代码
- 描述变化和 _为何_ 在这
- 遵循风格 (见下文)

## 代码风格

如果您要提交PR, 请阅读本文, 以尽量减少收到的傻瓜风格数量，并为维护人员节省时间.

### 在提交前

确保以运行 clang-format: `clang-format -i src/**/*{cpp,hpp}`

检查你的更改是否违反 `clang-tidy`. 这通常内置在你的IDE中.

### Clang-format

这是不可变的. 你的代码 **必须** 进行格式化.

### Clang-tidy

Clang-tidy 的违规行为并不是硬性要求, 但请尽量将其最小化, 只有在绝对必要时才忽略它们.

我已经调整了它, 所以在 99% 的情况下, 你绝对能修复它.

### 其他

有些东西 clang-tidy / clang-format 无法捕获:
- 没有未初始化的 _变量_ (int, float, double, size_t, 等)
- 没有简短的 ifs. 如果你的 if/else 主体包含 1 _line_ (不是 1 语句) 不要在它周围添加 `{}` .
- 上述规则不适用于循环等
- 考虑添加一个 `;` 在空功能体内部
- 当你初始化包含大量元素的向量或映射时, 在最后一个元素后添加一个 `,` 以保证美观
- 如果可能的话, 考虑在头文件中向前声明内容, 而不是包含内容. 加快编译时间.
- 不 `使用命名空间 std;`, 并且 `使用命名空间 (其他任何东西)` 只允许在源文件中使用, 而不允许在头文件中使用.
- 优先使用守卫语句而非嵌套. `if(!valid) return;` 好过 `if (valid) { /* a billion things */ }`

### 命名约定
虽然我们过去使用过匈牙利符号, 但我们正在远离它.
如果变量是类的成员, 则当前和新代码应使用带有 `m_` 前缀的 `camelCase`. (不是结构体)

此外:
 - 类的前缀为 `C`: `CMyClass`
 - 结构体的前缀为 `S`: `SMyStruct`
 - 命名空间的前缀为 `N`: `NMyNamespace`
 - 接口的前缀为 `I`: `IMyInterface`
 - 单例的全局指针的前缀为 `g_`: `g_someManager`
 - 常量变量用大写表示: `const auto MYVARIABLE = ...`

## 一般规范要求

### 没有原始指针
这是个简单规范 - 除非绝对必要, 否则绝对不要使用原始指针 (列如 `CMyClass*`) .
任你使用 `UP`, `SP` 和 `WP`.
他们分别是唯一指针, 共享指针和弱指针.

### 不要 malloc
除非绝对必要, 不要使用 malloc / free. 你 _会_ 忘记释放内存.

### 避免可疑的清理
如果一个函数是 C 风格的分配器, 列如. `some_c_call_make_new()`, 它可能需要 `some_c_call_free()`. 在这些情况下, 要么:
 - 将其封装在 C++ 类中, 或
 - 如果仅在一个函数中使用, 请使用 `CScopeGuard` 在函数退出时始终释放它.

### 使用 STL
一般来说, 使用 STL 而不是试图重新发明轮子.

### 使用 hyprutils
Hyprutils 提供了许多非常适合 hyprland (和其他 hypr* 项目) 的实用工具. 使用它们.

### /src 中没有绝对包含
想象一下这种情况:
```
src/
   a/
      a.hpp
   b/
      b.hpp
```

如果你想在 `a.hpp` 中包含 `b.hpp`, 你 _必须_ 使用 `../b/b.hpp`, _不要_ 使用 `b/b.hpp`. 后者会破坏插件.

您可能会在代码中注意到一个例外, 即允许从根目录开始的绝对路径, 例如 `protocols/some-protocol.hpp`.

### 测试你的修改
运行并测试你的修改确保他们可用!
